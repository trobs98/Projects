package events;

import publishers.AbstractPublisher;

/**
 * @author kkontog, ktsiouni, mgrigori
 *
 */
public class EventFactory {

	/**
	 * This is an implementation of the Factory Method design pattern Creates an
	 * instance of any of the subclasses derived from the top level class
	 * AbstractEvent
	 * 
	 * @param eventType
	 *            a member of the {@link EventType} enumeration
	 * @param eventPublisherId
	 *            a number generated by invoking the
	 *            {@link AbstractPublisher#hashCode()} on the
	 *            {@link AbstractPublisher} instance issuing the event
	 * @param payload
	 *            an object of type {@link EventMessage}
	 * @return
	 */

	public static AbstractEvent createEvent(EventType eventType, int eventPublisherId, EventMessage payload) {
		AbstractEvent e;

		switch (eventType) {
		case TypeA:
			e = new EventTypeA(EventIDMaker.getNewEventID(), eventPublisherId, payload);
			System.out.println("Event with header: [" + payload.getHeader() + "] and body: [" + payload.getBody() + "]");
			return e;
		case TypeB:
			e = new EventTypeB(EventIDMaker.getNewEventID(), eventPublisherId, payload);
			System.out.println("Event with header: [" + payload.getHeader() + "] and body: [" + payload.getBody() + "]");
			return e;
		case TypeC:
			e = new EventTypeC(EventIDMaker.getNewEventID(), eventPublisherId, payload);
			System.out.println("Event with header: [" + payload.getHeader() + "] and body: [" + payload.getBody() + "]");
		default:
			e = new EventTypeA(EventIDMaker.getNewEventID(), eventPublisherId, payload);
			System.out.println("Event with header: [" + payload.getHeader() + "] and body: [" + payload.getBody() + "]");
			return e;
		}
	}

}
/*
 * FIX eventID parameter in EventFactory AState BState CState DefaultState -
 * write handle event method A/B/D/Default strategy - write doPublish method
 * Check concrete subscriber classes
 */